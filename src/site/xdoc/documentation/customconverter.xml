<document>
  <properties>
    <author email="fgarsombke@yahoo.com">Franz Garsombke</author>
    <title>Custom Type Converters</title>
  </properties>
  <head>
    <meta http-equiv="CACHE-CONTROL" name="CACHE-CONTROL" CONTENT="NO-CACHE"/>    
    <meta http-equiv="PRAGMA" name="PRAGMA" CONTENT="NO-CACHE"/>     
    <META HTTP-EQUIV="EXPIRES" CONTENT="0"/>        
  </head>  
  <body>
    <section name="Custom Converters">
      <p>
        Custom converters are used to perform custom mapping between two objects.  In the Configuration block, you can add some XML to tell Dozer to use a custom converter for certain class A and class B types. 
        When a custom converter is specified for a class A and class B combination, Dozer will invoke the custom converter to perform the data mapping instead of the standard mapping logic.
      </p>
      <p>
        Your custom converter must implement the net.sf.dozer.util.mapping.converters.CustomConverter interface in order for Dozer to accept it. Otherwise an exception will be thrown.
        Please look in {dozer.home}/src/test for the classes TestCustomConverter.java and TestCustomHashMapConverter.java for examples.
      </p>
      <p>
      Custom converters are shared across mapping files. This means that you can define them once in a mapping file and it will be applied to all
      class mappings in other mapping files that match the Class A - Class B pattern.

      In the example below, whenever Dozer comes across a mapping where the src/dest class match the custom converter definition, it will invoke the custom converter class instead of performing
      the typical mapping.
      </p>
      <source>
        <![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mappings PUBLIC "-//DOZER//DTD MAPPINGS//EN"
   "http://dozer.sourceforge.net/dtd/dozerbeanmapping.dtd">
<mappings>
  <configuration>
    <custom-converters> <!-- these are always bi-directional -->
      <converter type="net.sf.dozer.util.mapping.converters.TestCustomConverter" >
        <class-a>net.sf.dozer.util.mapping.vo.CustomDoubleObject</class-a>
        <class-b>java.lang.Double</class-b>
      </converter>

      <!-- You are responsible for mapping everything between ClassA and ClassB -->
      <converter type="net.sf.dozer.util.mapping.converters.TestCustomHashMapConverter" >
        <class-a>net.sf.dozer.util.mapping.vo.TestCustomConverterHashMapObject</class-a>
        <class-b>net.sf.dozer.util.mapping.vo.TestCustomConverterHashMapPrimeObject</class-b>
      </converter>
     
    </custom-converters>     
  </configuration>
  
</mappings>
  
        ]]>
     </source>

     <p>
     Custom converters can also be specified at the individual field level.  In the example below, Dozer will invoke the custom converter to perform the field mapping.
     </p>


      <source>
        <![CDATA[

<mapping>
  <class-a>net.sf.dozer.util.mapping.vo.SimpleObj</class-a>
  <class-b>net.sf.dozer.util.mapping.vo.SimpleObjPrime2</class-b>    
  <field custom-converter="net.sf.dozer.util.mapping.converters.StringAppendCustomConverter">
    <a>field1</a>
    <b>field1Prime</b>
  </field>
</mapping>   
  
        ]]>
     </source>
     <p>
     Sample custom converter implementation:
     </p>
     
<source>
  <![CDATA[
public class TestCustomConverter implements CustomConverter {
  
  public Object convert(Object destination, Object source, Class destClass, Class sourceClass) {
    if (source == null) {
      return null;
    }
    CustomDoubleObject dest = null;
    if (source instanceof Double) {
      // check to see if the object already exists
      if (destination == null) {
        dest = new CustomDoubleObject();
      } else {
        dest = (CustomDoubleObject) destination;
      }
      dest.setTheDouble(((Double) source).doubleValue());
      return dest;
    } else if (source instanceof CustomDoubleObject) {
      double sourceObj = ((CustomDoubleObject) source).getTheDouble();
      return new Double(sourceObj);
    } else {
      throw new MappingException("Converter TestCustomConverter used incorrectly. Arguments passed in were:"
          + destination + " and " + source);
    }
  }     
    ]]>
 </source>
     <p> 
     </p>
     <p>
     CustomConverters can also be injected into the DozerBeanMapper if you need to do some manipulation
     with them before they are used in dozer.
     </p>
<source>
  <![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN"
  "http://www.springframework.org/dtd/spring-beans.dtd">

<beans default-lazy-init="false">

  <bean id="net.sf.dozer.util.mapping.MapperIF" class="net.sf.dozer.util.mapping.DozerBeanMapper" singleton="true">
    <property name="mappingFiles">
      <list>
        <value>systempropertymapping1.xml</value>
        <value>dozerBeanMapping.xml</value>
        <value>injectedCustomConverter.xml</value>
      </list>
    </property>
    <property name="factories">
      <map>
        <!-- the key matches the name of the factory in the dozerBeanMapping.xml file -->
       <entry key="net.sf.dozer.util.mapping.factories.SampleCustomBeanFactory">
         <ref bean="sampleCustomBeanFactory"/>
       </entry>
        <!-- more factories can be supplied with additional entry's -->
      </map>
    </property>    
    <property name="custom-converters">
      <list>
         <ref bean="customConverterTest"/>
      </list>
    </property>
  </bean>

  <bean id="NoExplicitMappingsMapperIF" class="net.sf.dozer.util.mapping.DozerBeanMapper" singleton="true">
  </bean>

  <bean id="sampleCustomBeanFactory" class="net.sf.dozer.util.mapping.factories.SampleCustomBeanFactory" singleton="true"/>

  <!-- custom converter -->
  <bean id="customConverterTest" class="net.sf.dozer.util.mapping.converters.InjectedCustomConverter" singleton="true">
    <property name="injectedName"><value>injectedName</value></property>
  </bean>

</beans>     
    ]]>
 </source>

    <subsection name="Support for Array Types">
      <p>
        You can specify a custom converter for Array types.  For example, if you want to use a custom converter for mapping between an array of objects and a String you would use the following mapping notation.  
        Dozer generically uses ClassLoader.loadClass() when parsing the mapping files. For arrays, java expects the class name in the following format.... 
        
        [Lnet.sf.dozer.util.mapping.vo.SimpleObj; 
      </p>

      <source>
        <![CDATA[
<converter type="net.sf.dozer.util.mapping.converters.StringAppendCustomConverter" > 
  <class-a>[Lnet.sf.dozer.util.mapping.vo.SimpleObj;</class-a> 
  <class-b>java.lang.String</class-b> 
</converter> 
        ]]>
     </source>

    </subsection>

    <subsection name="Support for primitives">
      <p>
        You can specify a custom converter for primitive types.  Just use the primitive wrapper class when defining the custom coverter mapping.  
        In the following example, Dozer will use the specified custom converter when mapping between SomeObject and the int primitive type.
        Note that Dozer will also use the custom converter when mapping between SomeObject and the Integer wrapper type.
      </p>

      <source>
        <![CDATA[
<converter type="somePackage.SomeCustomConverter" > 
  <class-a>somePackage.SomeObject</class-a> 
  <class-b>java.lang.Integer</class-b> 
</converter> 
        ]]>
     </source>

    </subsection>

    </section>    
  </body>
</document>