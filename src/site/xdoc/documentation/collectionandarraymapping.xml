<document>
  <properties>
    <author email="fgarsombke@yahoo.com">Franz Garsombke</author>
    <title>Collection and Array Mapping</title>
  </properties>
  <head>
    <meta http-equiv="CACHE-CONTROL" name="CACHE-CONTROL" CONTENT="NO-CACHE"/>    
    <meta http-equiv="PRAGMA" name="PRAGMA" CONTENT="NO-CACHE"/>     
    <META HTTP-EQUIV="EXPIRES" CONTENT="0"/>        
  </head>  
  <body>
    <section name="Collection and Array Mapping">
      <p>Dozer automatically maps between collection types and automatically performs any type conversion.  Each element in the source collection is mapped to an element in the dest object.  Hints are used to specify what type of objects are created in the destination collection.  The following collection mapping is automatically handled by Dozer: (These are all bi-directional)</p>
        <ul>
          <li>List to List</li>
          <li>List to Array</li>
          <li>Array to Array</li>
          <li>Set to Set</li>
          <li>Set to Array</li>
          <li>Set to List</li>
        </ul>
      <subsection name="Using Hints for Collection Mapping">
         <p>Hints are not required if you are using JDK 1.5 Generics or Arrays because the types can be autodetected by Dozer.  But if you are not using generics or Arrays, to convert a Collection/Array to a Collection/Array with different type objects you can specify a Hint to let Dozer know what type of objects you want created in the 
			destination list. If a Hint is not specified for the destination field, then the destination Collection will be populated with objects that are the same type 
			as the elements in the src Collection.
		 </p>
		 <br></br>
         <source>
           <![CDATA[ 
<field>
  <a>hintList</a> <!-- converting TheFirstSubClass List to TheFirstSubClassPrime List -->
  <b>hintList</b> 
  <b-hint>net.sf.dozer.util.mapping.vo.TheFirstSubClassPrime</b-hint> 
</field>    
            ]]>
          </source>
     <p>
     Below is a summary of the mapping logic used when mapping Arrays, Sets, and Lists. This gives a breakdown of what happens when 
     hints are or are not used.
     <ul>
       <li>List to List</li>
       <ul>
         <li>Dest Hint req'd: NO</li>
         <li>Dest Hint allowed: YES</li>
         <li>If no dest hint specified: Dest list will contain the same data types in the source</li>
         <li>If hint is speficied: Dest list will contain objects that match dest hint(s) type</li>
       </ul>
     </ul>
     <ul>
       <li>Array to List</li>
       <ul>
         <li>Dest Hint req'd: NO</li>
         <li>Dest Hint allowed: YES</li>
         <li>If no dest hint specified: Dest list will contain the same data types in the source</li>
         <li>If hint is speficied: Dest list will contain objects that match dest hint(s) type</li>
       </ul>
     </ul>
     <ul>
       <li>List to Array</li>
       <ul>
         <li>Dest Hint req'd: NO</li>
         <li>Dest Hint allowed: YES</li>
         <li>If no dest hint specified: Dest array will contain data types defined by the array</li>
         <li>If hint is speficied: Dest list will contain objects that match dest hint(s) type (only if Object Array)</li>
       </ul>
     </ul>
     <ul>
       <li>Array to Array</li>
       <ul>
         <li>Dest Hint req'd: NO</li>
         <li>Dest Hint allowed: YES</li>
         <li>If no dest hint specified: Dest array will contain data types defined by the array</li>
         <li>If hint is speficied: Dest list will contain objects that match dest hint(s) type (only if Object Array)</li>
       </ul>
     </ul>
     <ul>
       <li>Set to Set</li>
       <ul>
         <li>Dest Hint req'd: NO</li>
         <li>Dest Hint allowed: YES</li>
         <li>If no dest hint specified: Dest list will contain the same data types in the source</li>
         <li>If hint is speficied: Dest list will contain objects that match dest hint(s) type</li>
       </ul>
     </ul>
     <ul>
       <li>Array to Set</li>
       <ul>
         <li>Dest Hint req'd: NO</li>
         <li>Dest Hint allowed: YES</li>
         <li>If no dest hint specified: Dest list will contain the same data types in the source</li>
         <li>If hint is speficied: Dest list will contain objects that match dest hint(s) type</li>
       </ul>
     </ul>
     <ul>
       <li>Set to Array</li>
       <ul>
         <li>Dest Hint req'd: NO</li>
         <li>Dest Hint allowed: YES</li>
         <li>If no dest hint specified: Dest array will contain data types defined by the array</li>
         <li>If hint is speficied: Dest list will contain objects that match dest hint(s) type (only if Object Array)</li>
       </ul>
     </ul>
     <ul>
       <li>List to Set</li>
       <ul>
         <li>Dest Hint req'd: NO</li>
         <li>Dest Hint allowed: YES</li>
         <li>If no dest hint specified: Dest list will contain the same data types in the source</li>
         <li>If hint is speficied: Dest list will contain objects that match dest hint(s) type</li>
       </ul>
     </ul>
     <ul>
       <li>Set to List</li>
       <ul>
         <li>Dest Hint req'd: NO</li>
         <li>Dest Hint allowed: YES</li>
         <li>If no dest hint specified: Dest list will contain the same data types in the source</li>
         <li>If hint is speficied: Dest list will contain objects that match dest hint(s) type</li>
       </ul>
     </ul>
      </p>
      </subsection>        
      <subsection name="Using JDK 1.5 Generics for Collection Mapping">
         <p>Hints are not required when JDK 1.5 Generics are used.  To convert a Collection/Array to a Collection/Array with different type objects dozer can determine parameterized types at runtime.</p>
         <source>
           <![CDATA[ 
public class UserGroup {

  private Set<User> users;

  public Set<User> getUsers() {
    return users;
  }

  public void setUsers(Set<User> aUsers) {
    users = aUsers;
  }

}
public class UserGroupPrime {

  private List<UserPrime> users;

  public List<UserPrime> getUsers() {
    return users;
  }

  public void setUsers(List<UserPrime> aUsers) {
    users = aUsers;
  }

}
            ]]>
          </source>
     </subsection>
		
      <subsection name="Object Array to List (bi-directional)">
         <p>When converting an Object array to a List, by default the destination List will contain the same data type as the source Array.</p>
         <source>
           <![CDATA[ 
<field>
  <a>arrayForLists</a><!-- changing an Integer [] to List and back again -->
  <b>listForArray</b>
</field>    
            ]]>
          </source>
         <p>Use a hint for data type conversion.  Because a hint is specified, the destination List will contain String elements instead of Integers.</p>
         <source>
           <![CDATA[ 
<field>
  <a>arrayForLists</a><!-- changing an Integer [] to List and back again -->
  <b>listForArray</b>
  <b-hint>java.lang.String</b-hint> 
</field>    
            ]]>
          </source>
      </subsection>        
      <subsection name="Primitive Array to Primitive Array (bi-directional)">
         <p>When converting an Object array to an Array, by default the destination Array will contain the same data type as the source Array.</p>
         <source>
           <![CDATA[ 
<field>
  <a>anArray</a> <!-- converting int[] to int [] by name only -->
  <b>theMappedArray</b>
</field>      
            ]]>
          </source>
      </subsection>        
      <subsection name="Cumulative vs. Non-Cumulative List Mapping (bi-directional)">
         <p>If you are mapping to a Class which has already been initialized, dozer will either &apos;add&apos; or &apos;update&apos; objects to your List.  If your List or Set already has objects in it
         dozer checks the mapped List, Set, or Array and calls the contains() method to determine if it needs to &apos;add&apos; or &apos;update&apos;.
         This is determined using the relationship-type attribute on the field tag. The default is &apos;cumulative&apos;.</p>
         <source>
           <![CDATA[ 
<field relationship-type="cumulative">
  <a>hintList</a> <!-- objects will always be added to an existing List -->
  <b>hintList</b> 
  <a-hint>net.sf.dozer.util.mapping.vo.TheFirstSubClass</a-hint> 
  <b-hint>net.sf.dozer.util.mapping.vo.TheFirstSubClassPrime</b-hint> 
</field>    

<field relationship-type="non-cumulative">
  <a>unequalNamedList</a> <!-- objects will updated if already exist in List, added if they are not present -->
  <b>theMappedUnequallyNamedList</b> 
</field>    
            ]]>
          </source>
      </subsection>        

    </section>
  </body>
</document>